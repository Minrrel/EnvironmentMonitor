/******************************************************************************
 * Filename:       ENV_service.c
 *
 * Description:    This file contains the implementation of the service.
 *
 *                 Generated by:
 *                 BDS version: 1.0.2093.0
 *                 Plugin:      Texas Instruments CC26xx BLE SDK v2.1 GATT Server plugin 1.0.5 beta
 *                 Time:        Tue Jan 26 2016 22:57:47 GMT+01:00
 *

 * Copyright (c) 2015, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 **********************************************************************************/


/*********************************************************************
 * INCLUDES
 */
#include <string.h>

//#define xdc_runtime_Log_DISABLE_ALL 1  // Add to disable logs from this file
#include <xdc/runtime/Log.h>
#include <xdc/runtime/Diags.h>

#include "bcomdef.h"
#include "OSAL.h"
#include "linkdb.h"
#include "att.h"
#include "gatt.h"
#include "gatt_uuid.h"
#include "gattservapp.h"
#include "gapbondmgr.h"

#include "envservice.h"

/*********************************************************************
 * MACROS
 */

/*********************************************************************
 * CONSTANTS
 */

/*********************************************************************
 * TYPEDEFS
 */

/*********************************************************************
* GLOBAL VARIABLES
*/

// ENV_Service Service UUID
CONST uint8_t ENVServiceUUID[ATT_UUID_SIZE] =
{
  ENV_SERVICE_SERV_UUID_BASE128(ENV_SERVICE_SERV_UUID)
};


// Command UUID

CONST uint8_t es_COMMANDUUID[ATT_UUID_SIZE] =
{
  ES_COMMAND_UUID_BASE128(ES_COMMAND_UUID)
};


// Result UUID
CONST uint8_t es_RESULTUUID[ATT_UUID_SIZE] =
{
  ES_RESULT_UUID_BASE128(ES_RESULT_UUID)
};


//From the old UUID setup

/*
// MINTEMP UUID
CONST uint8_t ls_MINTEMPUUID[ATT_UUID_SIZE] =
{
  LS_MINTEMP_UUID_BASE128(LS_MINTEMP_UUID)
};

// MAXTEMP UUID
CONST uint8_t ls_MAXTEMPUUID[ATT_UUID_SIZE] =
{
  LS_MAXTEMP_UUID_BASE128(LS_MAXTEMP_UUID)
};

// MINPRESS UUID
CONST uint8_t ls_MINPRESSUUID[ATT_UUID_SIZE] =
{
  LS_MINPRESS_UUID_BASE128(LS_MINPRESS_UUID)
};

// MAXPRESS UUID
CONST uint8_t ls_MAXPRESSUUID[ATT_UUID_SIZE] =
{
  LS_MAXPRESS_UUID_BASE128(LS_MAXPRESS_UUID)
};


// MINHUM UUID
CONST uint8_t ls_MINHUMUUID[ATT_UUID_SIZE] =
{
  LS_MINHUM_UUID_BASE128(LS_MINHUM_UUID)
};

// MAXHUM UUID
CONST uint8_t ls_MAXHUMUUID[ATT_UUID_SIZE] =
{
  LS_MAXHUM_UUID_BASE128(LS_MAXHUM_UUID)
};


// MINRAIN UUID
CONST uint8_t ls_MINRAINUUID[ATT_UUID_SIZE] =
{
  LS_MINRAIN_UUID_BASE128(LS_MINRAIN_UUID)
};

// CURTEMP UUID
CONST uint8_t ls_CURTEMPUUID[ATT_UUID_SIZE] =
{
  LS_CURTEMP_UUID_BASE128(LS_CURTEMP_UUID)
};

// CURPRESS UUID
CONST uint8_t ls_CURPRESSUUID[ATT_UUID_SIZE] =
{
  LS_CURPRESS_UUID_BASE128(LS_CURPRESS_UUID)
};

// CURHUM UUID
CONST uint8_t ls_CURHUMUUID[ATT_UUID_SIZE] =
{
  LS_CURHUM_UUID_BASE128(LS_CURHUM_UUID)
};

// CURRAIN UUID
CONST uint8_t ls_CURRAINUUID[ATT_UUID_SIZE] =
{
  LS_CURRAIN_UUID_BASE128(LS_CURRAIN_UUID)
};
*/

/*********************************************************************
 * LOCAL VARIABLES
 */

static ENVServiceCBs_t *pAppCBs = NULL;

/*********************************************************************
* Profile Attributes - variables
*/

// Service declaration
static CONST gattAttrType_t ENVServiceDecl = { ATT_UUID_SIZE, ENVServiceUUID };


// Characteristic "Command" Properties (for declaration)
static uint8_t es_COMMANDProps = GATT_PROP_READ | GATT_PROP_WRITE | GATT_PROP_WRITE_NO_RSP;

// Characteristic "Command" Value variable
static uint8_t es_COMMANDVal[ES_COMMAND_LEN] = {0};

// Length of data in characteristic "MINTEMP" Value variable, initialized to minimal size.
static uint16_t es_COMMANDValLen = ES_COMMAND_LEN_MIN;



// Characteristic "Result" Properties (for declaration)
static uint8_t es_RESULTProps = GATT_PROP_READ | GATT_PROP_WRITE_NO_RSP;

// Characteristic "Result" Value variable
//static removed so can be global and set from other file
uint8_t es_RESULTVal[ES_RESULT_LEN] = {0};

// Length of data in characteristic "MAXTEMP" Value variable, initialized to minimal size.
static uint16_t es_RESULTValLen = ES_RESULT_LEN_MIN;





//For old UUID setup

/*

// Characteristic "MINTEMP" Properties (for declaration)
static uint8_t ls_MINTEMPProps = GATT_PROP_READ | GATT_PROP_WRITE | GATT_PROP_WRITE_NO_RSP;

// Characteristic "MINTEMP" Value variable
static uint8_t ls_MINTEMPVal[LS_MINTEMP_LEN] = {0};

// Length of data in characteristic "MINTEMP" Value variable, initialized to minimal size.
static uint16_t ls_MINTEMPValLen = LS_MINTEMP_LEN_MIN;



// Characteristic "MAXTEMP" Properties (for declaration)
static uint8_t ls_MAXTEMPProps = GATT_PROP_READ | GATT_PROP_WRITE | GATT_PROP_WRITE_NO_RSP;

// Characteristic "MAXTEMP" Value variable
static uint8_t ls_MAXTEMPVal[LS_MAXTEMP_LEN] = {0};

// Length of data in characteristic "MAXTEMP" Value variable, initialized to minimal size.
static uint16_t ls_MAXTEMPValLen = LS_MAXTEMP_LEN_MIN;



// Characteristic "MINPRESS" Properties (for declaration)
static uint8_t ls_MINPRESSProps = GATT_PROP_READ | GATT_PROP_WRITE | GATT_PROP_WRITE_NO_RSP;

// Characteristic "MINPRESS" Value variable
static uint8_t ls_MINPRESSVal[LS_MINPRESS_LEN] = {0};

// Length of data in characteristic "MINPRESS" Value variable, initialized to minimal size.
static uint16_t ls_MINPRESSValLen = LS_MINPRESS_LEN_MIN;



// Characteristic "MAXPRESS" Properties (for declaration)
static uint8_t ls_MAXPRESSProps = GATT_PROP_READ | GATT_PROP_WRITE | GATT_PROP_WRITE_NO_RSP;

// Characteristic "MAXPRESS" Value variable
static uint8_t ls_MAXPRESSVal[LS_MAXPRESS_LEN] = {0};

// Length of data in characteristic "MAXPRESS" Value variable, initialized to minimal size.
static uint16_t ls_MAXPRESSValLen = LS_MAXPRESS_LEN_MIN;



// Characteristic "MINHUM" Properties (for declaration)
static uint8_t ls_MINHUMProps = GATT_PROP_READ | GATT_PROP_WRITE | GATT_PROP_WRITE_NO_RSP;

// Characteristic "MINHUM" Value variable
static uint8_t ls_MINHUMVal[LS_MINHUM_LEN] = {0};

// Length of data in characteristic "MINHUM" Value variable, initialized to minimal size.
static uint16_t ls_MINHUMValLen = LS_MINHUM_LEN_MIN;


// Characteristic "MAXHUM" Properties (for declaration)
static uint8_t ls_MAXHUMProps = GATT_PROP_READ | GATT_PROP_WRITE | GATT_PROP_WRITE_NO_RSP;

// Characteristic "MAXHUM" Value variable
static uint8_t ls_MAXHUMVal[LS_MAXHUM_LEN] = {0};

// Length of data in characteristic "MAXHUM" Value variable, initialized to minimal size.
static uint16_t ls_MAXHUMValLen = LS_MAXHUM_LEN_MIN;



// Characteristic "MINRAIN" Properties (for declaration)
static uint8_t ls_MINRAINProps = GATT_PROP_READ | GATT_PROP_WRITE | GATT_PROP_WRITE_NO_RSP;

// Characteristic "MINRAIN" Value variable
static uint8_t ls_MINRAINVal[LS_MINRAIN_LEN] = {0};

// Length of data in characteristic "MINRAIN" Value variable, initialized to minimal size.
static uint16_t ls_MINRAINValLen = LS_MINRAIN_LEN_MIN;



// Characteristic "CURTEMP" Properties (for declaration)
static uint8_t ls_CURTEMPProps = GATT_PROP_READ | GATT_PROP_WRITE | GATT_PROP_WRITE_NO_RSP;

// Characteristic "CURTEMP" Value variable
static uint8_t ls_CURTEMPVal[LS_CURTEMP_LEN] = {0};

// Length of data in characteristic "CURTEMP" Value variable, initialized to minimal size.
static uint16_t ls_CURTEMPValLen = LS_CURTEMP_LEN_MIN;


// Characteristic "CURPRESS" Properties (for declaration)
static uint8_t ls_CURPRESSProps = GATT_PROP_READ | GATT_PROP_WRITE | GATT_PROP_WRITE_NO_RSP;

// Characteristic "CURPRESS" Value variable
static uint8_t ls_CURPRESSVal[LS_CURPRESS_LEN] = {0};

// Length of data in characteristic "CURPRESS" Value variable, initialized to minimal size.
static uint16_t ls_CURPRESSValLen = LS_CURPRESS_LEN_MIN;


// Characteristic "CURHUM" Properties (for declaration)
static uint8_t ls_CURHUMProps = GATT_PROP_READ | GATT_PROP_WRITE | GATT_PROP_WRITE_NO_RSP;

// Characteristic "CURHUM" Value variable
static uint8_t ls_CURHUMVal[LS_CURHUM_LEN] = {0};

// Length of data in characteristic "CURHUM" Value variable, initialized to minimal size.
static uint16_t ls_CURHUMValLen = LS_CURHUM_LEN_MIN;


// Characteristic "CURRAIN" Properties (for declaration)
static uint8_t ls_CURRAINProps = GATT_PROP_READ | GATT_PROP_WRITE | GATT_PROP_WRITE_NO_RSP;

// Characteristic "CURRAIN" Value variable
static uint8_t ls_CURRAINVal[LS_CURRAIN_LEN] = {0};

// Length of data in characteristic "CURRAIN" Value variable, initialized to minimal size.
static uint16_t ls_CURRAINValLen = LS_CURRAIN_LEN_MIN;
*/


/*********************************************************************
* Profile Attributes - Table
*/

static gattAttribute_t ENV_ServiceAttrTbl[] =
{
  // ENV_Service Service Declaration
  {
    { ATT_BT_UUID_SIZE, primaryServiceUUID },
    GATT_PERMIT_READ,
    0,
    (uint8_t *)&ENVServiceDecl
  },


  // Command Characteristic Declaration
  {
    { ATT_BT_UUID_SIZE, characterUUID },
    GATT_PERMIT_READ,
    0,
    &es_COMMANDProps
  },
    // Command Characteristic Value
    {
      { ATT_UUID_SIZE, es_COMMANDUUID },
      GATT_PERMIT_READ | GATT_PERMIT_WRITE | GATT_PERMIT_WRITE,
      0,
      es_COMMANDVal
    },
  // Result Characteristic Declaration
  {
    { ATT_BT_UUID_SIZE, characterUUID },
    GATT_PERMIT_READ,
    0,
    &es_RESULTProps
  },
    // Result Characteristic Value
    {
      { ATT_UUID_SIZE, es_RESULTUUID },
      GATT_PERMIT_READ  | GATT_PERMIT_WRITE,
      0,
      es_RESULTVal
    },


//from old uuid setup
  /*

    // MINTEMP Characteristic Declaration
    {
      { ATT_BT_UUID_SIZE, characterUUID },
      GATT_PERMIT_READ,
      0,
      &ls_MINTEMPProps
    },
      // MINTEMP Characteristic Value
      {
        { ATT_UUID_SIZE, ls_MINTEMPUUID },
        GATT_PERMIT_READ | GATT_PERMIT_WRITE | GATT_PERMIT_WRITE,
        0,
        ls_MINTEMPVal
      },
    // MAXTEMP Characteristic Declaration
    {
      { ATT_BT_UUID_SIZE, characterUUID },
      GATT_PERMIT_READ,
      0,
      &ls_MAXTEMPProps
    },
      // MAXTEMP Characteristic Value
      {
        { ATT_UUID_SIZE, ls_MAXTEMPUUID },
        GATT_PERMIT_READ | GATT_PERMIT_WRITE | GATT_PERMIT_WRITE,
        0,
        ls_MAXTEMPVal
      },


      // MINPRESS Characteristic Declaration
      {
        { ATT_BT_UUID_SIZE, characterUUID },
        GATT_PERMIT_READ,
        0,
        &ls_MINPRESSProps
      },
        // MINPRESS Characteristic Value
        {
          { ATT_UUID_SIZE, ls_MINPRESSUUID },
          GATT_PERMIT_READ | GATT_PERMIT_WRITE | GATT_PERMIT_WRITE,
          0,
          ls_MINPRESSVal
        },
      // MAXPRESS Characteristic Declaration
      {
        { ATT_BT_UUID_SIZE, characterUUID },
        GATT_PERMIT_READ,
        0,
        &ls_MAXPRESSProps
      },
        // MAXPRESS Characteristic Value
        {
          { ATT_UUID_SIZE, ls_MAXPRESSUUID },
          GATT_PERMIT_READ | GATT_PERMIT_WRITE | GATT_PERMIT_WRITE,
          0,
          ls_MAXPRESSVal
        },


        // MINHUM Characteristic Declaration
        {
          { ATT_BT_UUID_SIZE, characterUUID },
          GATT_PERMIT_READ,
          0,
          &ls_MINHUMProps
        },
          // MINHUM Characteristic Value
          {
            { ATT_UUID_SIZE, ls_MINHUMUUID },
            GATT_PERMIT_READ | GATT_PERMIT_WRITE | GATT_PERMIT_WRITE,
            0,
            ls_MINHUMVal
          },
        // MAXHUM Characteristic Declaration
        {
          { ATT_BT_UUID_SIZE, characterUUID },
          GATT_PERMIT_READ,
          0,
          &ls_MAXHUMProps
        },
          // MAXHUM Characteristic Value
          {
            { ATT_UUID_SIZE, ls_MAXHUMUUID },
            GATT_PERMIT_READ | GATT_PERMIT_WRITE | GATT_PERMIT_WRITE,
            0,
            ls_MAXHUMVal
          },


          // MINRAIN Characteristic Declaration
          {
            { ATT_BT_UUID_SIZE, characterUUID },
            GATT_PERMIT_READ,
            0,
            &ls_MINRAINProps
          },
            // MINRAIN Characteristic Value
            {
              { ATT_UUID_SIZE, ls_MINRAINUUID },
              GATT_PERMIT_READ | GATT_PERMIT_WRITE | GATT_PERMIT_WRITE,
              0,
              ls_MINRAINVal
            },



            // CURTEMP Characteristic Declaration
            {
              { ATT_BT_UUID_SIZE, characterUUID },
              GATT_PERMIT_READ,
              0,
              &ls_CURTEMPProps
            },
              // CURTEMP Characteristic Value
              {
                { ATT_UUID_SIZE, ls_CURTEMPUUID },
                GATT_PERMIT_READ | GATT_PERMIT_WRITE | GATT_PERMIT_WRITE,
                0,
                ls_CURTEMPVal
              },

              // CURPRESS Characteristic Declaration
              {
                { ATT_BT_UUID_SIZE, characterUUID },
                GATT_PERMIT_READ,
                0,
                &ls_CURPRESSProps
              },
                // CURPRESS Characteristic Value
                {
                  { ATT_UUID_SIZE, ls_CURPRESSUUID },
                  GATT_PERMIT_READ | GATT_PERMIT_WRITE | GATT_PERMIT_WRITE,
                  0,
                  ls_CURPRESSVal
                },


                // CURHUM Characteristic Declaration
                {
                  { ATT_BT_UUID_SIZE, characterUUID },
                  GATT_PERMIT_READ,
                  0,
                  &ls_CURHUMProps
                },
                  // CURHUM Characteristic Value
                  {
                    { ATT_UUID_SIZE, ls_CURHUMUUID },
                    GATT_PERMIT_READ | GATT_PERMIT_WRITE | GATT_PERMIT_WRITE,
                    0,
                    ls_CURHUMVal
                  },


                  // CURRAIN Characteristic Declaration
                  {
                    { ATT_BT_UUID_SIZE, characterUUID },
                    GATT_PERMIT_READ,
                    0,
                    &ls_CURRAINProps
                  },
                    // CURRAIN Characteristic Value
                    {
                      { ATT_UUID_SIZE, ls_CURRAINUUID },
                      GATT_PERMIT_READ | GATT_PERMIT_WRITE | GATT_PERMIT_WRITE,
                      0,
                      ls_CURRAINVal
                    },
*/
};

/*********************************************************************
 * LOCAL FUNCTIONS
 */
static bStatus_t ENV_Service_ReadAttrCB( uint16_t connHandle, gattAttribute_t *pAttr,
                                           uint8_t *pValue, uint16_t *pLen, uint16_t offset,
                                           uint16_t maxLen, uint8_t method );
static bStatus_t ENV_Service_WriteAttrCB( uint16_t connHandle, gattAttribute_t *pAttr,
                                            uint8_t *pValue, uint16_t len, uint16_t offset,
                                            uint8_t method );

/*********************************************************************
 * PROFILE CALLBACKS
 */
// Simple Profile Service Callbacks
CONST gattServiceCBs_t ENV_ServiceCBs =
{
  ENV_Service_ReadAttrCB,  // Read callback function pointer
  ENV_Service_WriteAttrCB, // Write callback function pointer
  NULL                       // Authorization callback function pointer
};

/*********************************************************************
* PUBLIC FUNCTIONS
*/

/*
 * ENVService_AddService- Initializes the ENVService service by registering
 *          GATT attributes with the GATT server.
 *
 *    rspTaskId - The ICall Task Id that should receive responses for Indications.
 */
extern bStatus_t ENVService_AddService( uint8_t rspTaskId )
{
  uint8_t status;

  // Register GATT attribute list and CBs with GATT Server App
  status = GATTServApp_RegisterService( ENV_ServiceAttrTbl,
                                        GATT_NUM_ATTRS( ENV_ServiceAttrTbl ),
                                        GATT_MAX_ENCRYPT_KEY_SIZE,
                                        &ENV_ServiceCBs );
  Log_info1("Registered service, %d attributes", (IArg)GATT_NUM_ATTRS( ENV_ServiceAttrTbl ));
  return ( status );
}

/*
 * ENVService_RegisterAppCBs - Registers the application callback function.
 *                    Only call this function once.
 *
 *    appCallbacks - pointer to application callbacks.
 */
bStatus_t ENVService_RegisterAppCBs( ENVServiceCBs_t *appCallbacks )
{
  if ( appCallbacks )
  {
    pAppCBs = appCallbacks;
    Log_info1("Registered callbacks to application. Struct %p", (IArg)appCallbacks);
    return ( SUCCESS );
  }
  else
  {
    Log_warning0("Null pointer given for app callbacks.");
    return ( FAILURE );
  }
}

/*
 * ENVService_SetParameter - Set a ENVService parameter.
 *
 *    param - Profile parameter ID
 *    len   - length of data to write
 *    value - pointer to data to write.  This is dependent on
 *            the parameter ID and may be cast to the appropriate
 *            data type (example: data type of uint16_t will be cast to
 *            uint16_t pointer).
 */
bStatus_t ENVService_SetParameter( uint8_t param, uint16_t len, void *value )
{
  bStatus_t ret = SUCCESS;
  uint8_t  *pAttrVal;
  uint16_t *pValLen;
  uint16_t valMinLen;
  uint16_t valMaxLen;

  switch ( param )
  {
    case ES_COMMAND_ID :
      pAttrVal  =  es_COMMANDVal;
      pValLen   = &es_COMMANDValLen;
      valMinLen =  ES_COMMAND_LEN_MIN;
      valMaxLen =  ES_COMMAND_LEN;
      Log_info2("SetParameter : %s len: %d", (IArg)"MINTEMP", (IArg)len);
      break;

    case ES_RESULT_ID:
      pAttrVal  =  es_RESULTVal;
      pValLen   = &es_RESULTValLen;
      valMinLen =  ES_RESULT_LEN_MIN;
      valMaxLen =  ES_RESULT_LEN;
      Log_info2("SetParameter : %s len: %d", (IArg)"MAXTEMP", (IArg)len);
      break;
  }


//From the old setup of UUIDs
/*
  switch ( param )
  {
    case LS_MINTEMP_ID:
      pAttrVal  =  ls_MINTEMPVal;
      pValLen   = &ls_MINTEMPValLen;
      valMinLen =  LS_MINTEMP_LEN_MIN;
      valMaxLen =  LS_MINTEMP_LEN;
      Log_info2("SetParameter : %s len: %d", (IArg)"MINTEMP", (IArg)len);
      break;

    case LS_MAXTEMP_ID:
      pAttrVal  =  ls_MAXTEMPVal;
      pValLen   = &ls_MAXTEMPValLen;
      valMinLen =  LS_MAXTEMP_LEN_MIN;
      valMaxLen =  LS_MAXTEMP_LEN;
      Log_info2("SetParameter : %s len: %d", (IArg)"MAXTEMP", (IArg)len);
      break;

    case LS_MINPRESS_ID:
      pAttrVal  =  ls_MINPRESSVal;
      pValLen   = &ls_MINPRESSValLen;
      valMinLen =  LS_MINPRESS_LEN_MIN;
      valMaxLen =  LS_MINPRESS_LEN;
      Log_info2("SetParameter : %s len: %d", (IArg)"MINPRESS", (IArg)len);
      break;

    case LS_MAXPRESS_ID:
      pAttrVal  =  ls_MAXPRESSVal;
      pValLen   = &ls_MAXPRESSValLen;
      valMinLen =  LS_MAXPRESS_LEN_MIN;
      valMaxLen =  LS_MAXPRESS_LEN;
      Log_info2("SetParameter : %s len: %d", (IArg)"MAXPRESS", (IArg)len);
      break;

    case LS_MINHUM_ID:
      pAttrVal  =  ls_MINHUMVal;
      pValLen   = &ls_MINHUMValLen;
      valMinLen =  LS_MINHUM_LEN_MIN;
      valMaxLen =  LS_MINHUM_LEN;
      Log_info2("SetParameter : %s len: %d", (IArg)"MINHUM", (IArg)len);
      break;

    case LS_MAXHUM_ID:
      pAttrVal  =  ls_MAXHUMVal;
      pValLen   = &ls_MAXHUMValLen;
      valMinLen =  LS_MAXHUM_LEN_MIN;
      valMaxLen =  LS_MAXHUM_LEN;
      Log_info2("SetParameter : %s len: %d", (IArg)"MAXHUM", (IArg)len);
      break;

    case LS_MINRAIN_ID:
      pAttrVal  =  ls_MINRAINVal;
      pValLen   = &ls_MINRAINValLen;
      valMinLen =  LS_MINRAIN_LEN_MIN;
      valMaxLen =  LS_MINRAIN_LEN;
      Log_info2("SetParameter : %s len: %d", (IArg)"MINRAIN", (IArg)len);
      break;


    case LS_CURTEMP_ID:
      pAttrVal  =  ls_CURTEMPVal;
      pValLen   = &ls_CURTEMPValLen;
      valMinLen =  LS_CURTEMP_LEN_MIN;
      valMaxLen =  LS_CURTEMP_LEN;
      Log_info2("SetParameter : %s len: %d", (IArg)"CURTEMP", (IArg)len);
      break;


    case LS_CURPRESS_ID:
      pAttrVal  =  ls_CURPRESSVal;
      pValLen   = &ls_CURPRESSValLen;
      valMinLen =  LS_CURPRESS_LEN_MIN;
      valMaxLen =  LS_CURPRESS_LEN;
      Log_info2("SetParameter : %s len: %d", (IArg)"CURPRESS", (IArg)len);
      break;

    case LS_CURHUM_ID:
      pAttrVal  =  ls_CURHUMVal;
      pValLen   = &ls_CURHUMValLen;
      valMinLen =  LS_CURHUM_LEN_MIN;
      valMaxLen =  LS_CURHUM_LEN;
      Log_info2("SetParameter : %s len: %d", (IArg)"CURHUM", (IArg)len);
      break;

    case LS_CURRAIN_ID:
      pAttrVal  =  ls_CURRAINVal;
      pValLen   = &ls_CURRAINValLen;
      valMinLen =  LS_CURRAIN_LEN_MIN;
      valMaxLen =  LS_CURRAIN_LEN;
      Log_info2("SetParameter : %s len: %d", (IArg)"CURRAIN", (IArg)len);
      break;

    default:
      Log_error1("SetParameter: Parameter #%d not valid.", (IArg)param);
      return INVALIDPARAMETER;
  }
*/
  // Check bounds, update value and send notification or indication if possible.
  if ( len <= valMaxLen && len >= valMinLen )
  {
    memcpy(pAttrVal, value, len);
    *pValLen = len; // Update length for read and get.
  }
  else
  {
    Log_error3("Length outside bounds: Len: %d MinLen: %d MaxLen: %d.", (IArg)len, (IArg)valMinLen, (IArg)valMaxLen);
    ret = bleInvalidRange;
  }

  return ret;
}


/*
 * ENVService_GetParameter - Get a ENVService parameter.
 *
 *    param - Profile parameter ID
 *    len   - pointer to a variable that contains the maximum length that can be written to *value.
              After the call, this value will contain the actual returned length.
 *    value - pointer to data to write.  This is dependent on
 *            the parameter ID and may be cast to the appropriate
 *            data type (example: data type of uint16_t will be cast to
 *            uint16_t pointer).
 */
bStatus_t ENVService_GetParameter( uint8_t param, uint16_t *len, void *value )
{
  bStatus_t ret = SUCCESS;
  switch ( param )
  {

  case ES_COMMAND_ID:
    *len = MIN(*len, es_COMMANDValLen);
    memcpy(value, es_COMMANDVal, *len);
    Log_info2("GetParameter : %s returning %d bytes", (IArg)"MAXTEMP", (IArg)*len);
    break;


  case ES_RESULT_ID:
    *len = MIN(*len, es_RESULTValLen);
    memcpy(value, es_RESULTVal, *len);
    Log_info2("GetParameter : %s returning %d bytes", (IArg)"MINTEMP", (IArg)*len);
    break;

//From the old UUID setup
/*
    case LS_MINTEMP_ID:
      *len = MIN(*len, ls_MINTEMPValLen);
      memcpy(value, ls_MINTEMPVal, *len);
      Log_info2("GetParameter : %s returning %d bytes", (IArg)"MINTEMP", (IArg)*len);
      break;

    case LS_MAXTEMP_ID:
      *len = MIN(*len, ls_MAXTEMPValLen);
      memcpy(value, ls_MAXTEMPVal, *len);
      Log_info2("GetParameter : %s returning %d bytes", (IArg)"MAXTEMP", (IArg)*len);
      break;

    case LS_MINPRESS_ID:
      *len = MIN(*len, ls_MINPRESSValLen);
      memcpy(value, ls_MINPRESSVal, *len);
      Log_info2("GetParameter : %s returning %d bytes", (IArg)"MINPRESS", (IArg)*len);
      break;

    case LS_MAXPRESS_ID:
      *len = MIN(*len, ls_MAXPRESSValLen);
      memcpy(value, ls_MAXPRESSVal, *len);
      Log_info2("GetParameter : %s returning %d bytes", (IArg)"MAXPRESS", (IArg)*len);
      break;

    case LS_MINHUM_ID:
      *len = MIN(*len, ls_MINHUMValLen);
      memcpy(value, ls_MINHUMVal, *len);
      Log_info2("GetParameter : %s returning %d bytes", (IArg)"MINHUM", (IArg)*len);
      break;

    case LS_MAXHUM_ID:
      *len = MIN(*len, ls_MAXHUMValLen);
      memcpy(value, ls_MAXHUMVal, *len);
      Log_info2("GetParameter : %s returning %d bytes", (IArg)"MAXHUM", (IArg)*len);
      break;


    case LS_MINRAIN_ID:
      *len = MIN(*len, ls_MINRAINValLen);
      memcpy(value, ls_MINRAINVal, *len);
      Log_info2("GetParameter : %s returning %d bytes", (IArg)"MINRAIN", (IArg)*len);
      break;

    case LS_CURTEMP_ID:
      *len = MIN(*len, ls_CURTEMPValLen);
      memcpy(value, ls_CURTEMPVal, *len);
      Log_info2("GetParameter : %s returning %d bytes", (IArg)"CURTEMP", (IArg)*len);
      break;

    case LS_CURPRESS_ID:
      *len = MIN(*len, ls_CURPRESSValLen);
      memcpy(value, ls_CURPRESSVal, *len);
      Log_info2("GetParameter : %s returning %d bytes", (IArg)"CURPRESS", (IArg)*len);
      break;


    case LS_CURHUM_ID:
      *len = MIN(*len, ls_CURHUMValLen);
      memcpy(value, ls_CURHUMVal, *len);
      Log_info2("GetParameter : %s returning %d bytes", (IArg)"CURHUM", (IArg)*len);
      break;


    case LS_CURRAIN_ID:
      *len = MIN(*len, ls_CURRAINValLen);
      memcpy(value, ls_CURRAINVal, *len);
      Log_info2("GetParameter : %s returning %d bytes", (IArg)"CURRAIN", (IArg)*len);
      break;
*/

    default:
      Log_error1("GetParameter: Parameter #%d not valid.", (IArg)param);
      ret = INVALIDPARAMETER;
      break;
  }
  return ret;
}

/*********************************************************************
 * @internal
 * @fn          ENV_Service_findCharParamId
 *
 * @brief       Find the logical param id of an attribute in the service's attr table.
 *
 *              Works only for Characteristic Value attributes and
 *              Client Characteristic Configuration Descriptor attributes.
 *
 * @param       pAttr - pointer to attribute
 *
 * @return      uint8_t paramID (ref ENV_service.h) or 0xFF if not found.
 */
static uint8_t ENV_Service_findCharParamId(gattAttribute_t *pAttr)
{
  // Is this a Client Characteristic Configuration Descriptor?
  if (ATT_BT_UUID_SIZE == pAttr->type.len && GATT_CLIENT_CHAR_CFG_UUID == *(uint16_t *)pAttr->type.uuid)
    return ENV_Service_findCharParamId(pAttr - 1); // Assume the value attribute precedes CCCD and recurse

  // Is this attribute in "COMMAND"?
  else if ( ATT_UUID_SIZE == pAttr->type.len && !memcmp(pAttr->type.uuid, es_COMMANDUUID, pAttr->type.len))
    return ES_COMMAND_ID;

  // Is this attribute in "RESULT"?
  else if ( ATT_UUID_SIZE == pAttr->type.len && !memcmp(pAttr->type.uuid, es_RESULTUUID, pAttr->type.len))
    return ES_RESULT_ID;


//From the old UUID setup
/*
  // Is this attribute in "MINTEMP"?
  else if ( ATT_UUID_SIZE == pAttr->type.len && !memcmp(pAttr->type.uuid, ls_MINTEMPUUID, pAttr->type.len))
    return LS_MINTEMP_ID;

  // Is this attribute in "MAXTEMP"?
  else if ( ATT_UUID_SIZE == pAttr->type.len && !memcmp(pAttr->type.uuid, ls_MAXTEMPUUID, pAttr->type.len))
    return LS_MAXTEMP_ID;

  // Is this attribute in "MINPRESS"?
  else if ( ATT_UUID_SIZE == pAttr->type.len && !memcmp(pAttr->type.uuid, ls_MINPRESSUUID, pAttr->type.len))
    return LS_MINPRESS_ID;

  // Is this attribute in "MAXPRESS"?
  else if ( ATT_UUID_SIZE == pAttr->type.len && !memcmp(pAttr->type.uuid, ls_MAXPRESSUUID, pAttr->type.len))
    return LS_MAXPRESS_ID;

  // Is this attribute in "MINHUM"?
  else if ( ATT_UUID_SIZE == pAttr->type.len && !memcmp(pAttr->type.uuid, ls_MINHUMUUID, pAttr->type.len))
    return LS_MINHUM_ID;

  // Is this attribute in "MAXHUM"?
  else if ( ATT_UUID_SIZE == pAttr->type.len && !memcmp(pAttr->type.uuid, ls_MAXHUMUUID, pAttr->type.len))
    return LS_MAXHUM_ID;

  // Is this attribute in "MINRAIN"?
  else if ( ATT_UUID_SIZE == pAttr->type.len && !memcmp(pAttr->type.uuid, ls_MINRAINUUID, pAttr->type.len))
    return LS_MINRAIN_ID;

  // Is this attribute in "CURTEMP"?
  else if ( ATT_UUID_SIZE == pAttr->type.len && !memcmp(pAttr->type.uuid, ls_CURTEMPUUID, pAttr->type.len))
    return LS_CURTEMP_ID;


  // Is this attribute in "CURPRESS"?
  else if ( ATT_UUID_SIZE == pAttr->type.len && !memcmp(pAttr->type.uuid, ls_CURPRESSUUID, pAttr->type.len))
    return LS_CURPRESS_ID;

  // Is this attribute in "CURHUM"?
  else if ( ATT_UUID_SIZE == pAttr->type.len && !memcmp(pAttr->type.uuid, ls_CURHUMUUID, pAttr->type.len))
    return LS_CURHUM_ID;

  // Is this attribute in "CURRAIN"?
  else if ( ATT_UUID_SIZE == pAttr->type.len && !memcmp(pAttr->type.uuid, ls_CURRAINUUID, pAttr->type.len))
    return LS_CURRAIN_ID;
*/
  else
    return 0xFF; // Not found. Return invalid.
}

/*********************************************************************
 * @fn          ENV_Service_ReadAttrCB
 *
 * @brief       Read an attribute.
 *
 * @param       connHandle - connection message was received on
 * @param       pAttr - pointer to attribute
 * @param       pValue - pointer to data to be read
 * @param       pLen - length of data to be read
 * @param       offset - offset of the first octet to be read
 * @param       maxLen - maximum length of data to be read
 * @param       method - type of read message
 *
 * @return      SUCCESS, blePending or Failure
 */
static bStatus_t ENV_Service_ReadAttrCB( uint16_t connHandle, gattAttribute_t *pAttr,
                                       uint8_t *pValue, uint16_t *pLen, uint16_t offset,
                                       uint16_t maxLen, uint8_t method )
{
  bStatus_t status = SUCCESS;
  uint16_t valueLen;
  uint8_t paramID = 0xFF;

  // Find settings for the characteristic to be read.
  paramID = ENV_Service_findCharParamId( pAttr );
  switch ( paramID )
  {

  case ES_COMMAND_ID:
    valueLen = es_COMMANDValLen;

    Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
               (IArg)"COMMAND",
               (IArg)connHandle,
               (IArg)offset,
               (IArg)method);
    break;

  case ES_RESULT_ID:
    valueLen = es_RESULTValLen;

    Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
               (IArg)"RESULT",
               (IArg)connHandle,
               (IArg)offset,
               (IArg)method);
    break;


    //From the old UUID setup
  /*
    case LS_MINTEMP_ID:
      valueLen = ls_MINTEMPValLen;

      Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                 (IArg)"MINTEMP",
                 (IArg)connHandle,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for MINTEMP can be inserted here
      break;

    case LS_MAXTEMP_ID:
      valueLen = ls_MAXTEMPValLen;

      Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                 (IArg)"MAXTEMP",
                 (IArg)connHandle,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for MAXTEMP can be inserted here
      break;

    case LS_MINPRESS_ID:
      valueLen = ls_MINPRESSValLen;

      Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                 (IArg)"MINPRESS",
                 (IArg)connHandle,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for MINPRESS can be inserted here
      break;

    case LS_MAXPRESS_ID:
      valueLen = ls_MAXPRESSValLen;

      Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                 (IArg)"MAXPRESS",
                 (IArg)connHandle,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for MAXPRESS can be inserted here
      break;

    case LS_MINHUM_ID:
      valueLen = ls_MINHUMValLen;

      Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                 (IArg)"MINHUM",
                 (IArg)connHandle,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for MINHUM can be inserted here
      break;

    case LS_MAXHUM_ID:
      valueLen = ls_MAXHUMValLen;

      Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                 (IArg)"MAXHUM",
                 (IArg)connHandle,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for MAXHUM can be inserted here
      break;

    case LS_MINRAIN_ID:
      valueLen = ls_MINRAINValLen;

      Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                 (IArg)"MINRAIN",
                 (IArg)connHandle,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for MINRAIN can be inserted here
      break;

    case LS_CURTEMP_ID:
      valueLen = ls_CURTEMPValLen;

      Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                 (IArg)"CURTEMP",
                 (IArg)connHandle,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for CURTEMP can be inserted here
      break;

    case LS_CURPRESS_ID:
      valueLen = ls_CURPRESSValLen;

      Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                 (IArg)"CURPRESS",
                 (IArg)connHandle,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for CURPRESS can be inserted here
      break;

    case LS_CURHUM_ID:
      valueLen = ls_CURHUMValLen;

      Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                 (IArg)"CURHUM",
                 (IArg)connHandle,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for CURHUM can be inserted here
      break;

    case LS_CURRAIN_ID:
      valueLen = ls_CURRAINValLen;

      Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                 (IArg)"CURRAIN",
                 (IArg)connHandle,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for CURRAIN can be inserted here
      break;
*/
    default:
      Log_error0("Attribute was not found.");
      return ATT_ERR_ATTR_NOT_FOUND;
  }
  // Check bounds and return the value
  if ( offset > valueLen )  // Prevent malicious ATT ReadBlob offsets.
  {
    Log_error0("An invalid offset was requested.");
    status = ATT_ERR_INVALID_OFFSET;
  }
  else
  {
    *pLen = MIN(maxLen, valueLen - offset);  // Transmit as much as possible
    memcpy(pValue, pAttr->pValue + offset, *pLen);
  }

  return status;
}

/*********************************************************************
 * @fn      ENV_Service_WriteAttrCB
 *
 * @brief   Validate attribute data prior to a write operation
 *
 * @param   connHandle - connection message was received on
 * @param   pAttr - pointer to attribute
 * @param   pValue - pointer to data to be written
 * @param   len - length of data
 * @param   offset - offset of the first octet to be written
 * @param   method - type of write message
 *
 * @return  SUCCESS, blePending or Failure
 */
static bStatus_t ENV_Service_WriteAttrCB( uint16_t connHandle, gattAttribute_t *pAttr,
                                        uint8_t *pValue, uint16_t len, uint16_t offset,
                                        uint8_t method )
{
  bStatus_t status  = SUCCESS;
  uint8_t   paramID = 0xFF;
  uint8_t   changeParamID = 0xFF;
  uint16_t writeLenMin;
  uint16_t writeLenMax;
  uint16_t *pValueLenVar;

  // Find settings for the characteristic to be written.
  paramID = ENV_Service_findCharParamId( pAttr );
  switch ( paramID )
  {


  case ES_COMMAND_ID:
    writeLenMin  = ES_COMMAND_LEN_MIN;
    writeLenMax  = ES_COMMAND_LEN;
    pValueLenVar = &es_COMMANDValLen;

    Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
               (IArg)"COMMAND",
               (IArg)connHandle,
               (IArg)len,
               (IArg)offset,
               (IArg)method);
    break;

  case ES_RESULT_ID:
    writeLenMin  = ES_RESULT_LEN_MIN;
    writeLenMax  = ES_RESULT_LEN;
    pValueLenVar = &es_RESULTValLen;

    Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
               (IArg)"RESULT",
               (IArg)connHandle,
               (IArg)len,
               (IArg)offset,
               (IArg)method);
    break;


    //From the old UUID setup
/*

    case LS_MINTEMP_ID:
      writeLenMin  = LS_MINTEMP_LEN_MIN;
      writeLenMax  = LS_MINTEMP_LEN;
      pValueLenVar = &ls_MINTEMPValLen;

      Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
                 (IArg)"MINTEMP",
                 (IArg)connHandle,
                 (IArg)len,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for MINTEMP can be inserted here
      break;

    case LS_MAXTEMP_ID:
      writeLenMin  = LS_MAXTEMP_LEN_MIN;
      writeLenMax  = LS_MAXTEMP_LEN;
      pValueLenVar = &ls_MAXTEMPValLen;

      Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
                 (IArg)"MAXTEMP",
                 (IArg)connHandle,
                 (IArg)len,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for MAXTEMP can be inserted here
      break;


    case LS_MINPRESS_ID:
      writeLenMin  = LS_MINPRESS_LEN_MIN;
      writeLenMax  = LS_MINPRESS_LEN;
      pValueLenVar = &ls_MINPRESSValLen;

      Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
                 (IArg)"MINPRESS",
                 (IArg)connHandle,
                 (IArg)len,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for MINPRESS can be inserted here
      break;

    case LS_MAXPRESS_ID:
      writeLenMin  = LS_MAXPRESS_LEN_MIN;
      writeLenMax  = LS_MAXPRESS_LEN;
      pValueLenVar = &ls_MAXPRESSValLen;

      Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
                 (IArg)"MAXPRESS",
                 (IArg)connHandle,
                 (IArg)len,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for MAXPRESS can be inserted here
      break;

    case LS_MINHUM_ID:
      writeLenMin  = LS_MINHUM_LEN_MIN;
      writeLenMax  = LS_MINHUM_LEN;
      pValueLenVar = &ls_MINHUMValLen;

      Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
                 (IArg)"MINHUM",
                 (IArg)connHandle,
                 (IArg)len,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for MINHUM can be inserted here
      break;

    case LS_MAXHUM_ID:
      writeLenMin  = LS_MAXHUM_LEN_MIN;
      writeLenMax  = LS_MAXHUM_LEN;
      pValueLenVar = &ls_MAXHUMValLen;

      Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
                 (IArg)"MAXHUM",
                 (IArg)connHandle,
                 (IArg)len,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for MAXHUM can be inserted here
      break;

    case LS_MINRAIN_ID:
      writeLenMin  = LS_MINRAIN_LEN_MIN;
      writeLenMax  = LS_MINRAIN_LEN;
      pValueLenVar = &ls_MINRAINValLen;

      Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
                 (IArg)"MINRAIN",
                 (IArg)connHandle,
                 (IArg)len,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for MINRAIN can be inserted here
      break;

    case LS_CURTEMP_ID:
      writeLenMin  = LS_CURTEMP_LEN_MIN;
      writeLenMax  = LS_CURTEMP_LEN;
      pValueLenVar = &ls_CURTEMPValLen;

      Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
                 (IArg)"CURTEMP",
                 (IArg)connHandle,
                 (IArg)len,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for CURTEMP can be inserted here
      break;

    case LS_CURPRESS_ID:
      writeLenMin  = LS_CURPRESS_LEN_MIN;
      writeLenMax  = LS_CURPRESS_LEN;
      pValueLenVar = &ls_CURPRESSValLen;

      Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
                 (IArg)"CURPRESS",
                 (IArg)connHandle,
                 (IArg)len,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for CURPRESS can be inserted here
      break;

   case LS_CURHUM_ID:
      writeLenMin  = LS_CURHUM_LEN_MIN;
      writeLenMax  = LS_CURHUM_LEN;
      pValueLenVar = &ls_CURHUMValLen;

      Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
                 (IArg)"CURHUM",
                 (IArg)connHandle,
                 (IArg)len,
                 (IArg)offset,
                 (IArg)method);
      // Other considerations for CURHUM can be inserted here
      break;


   case LS_CURRAIN_ID:
     writeLenMin  = LS_CURRAIN_LEN_MIN;
     writeLenMax  = LS_CURRAIN_LEN;
     pValueLenVar = &ls_CURRAINValLen;

     Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
                (IArg)"CURRAIN",
                (IArg)connHandle,
                (IArg)len,
                (IArg)offset,
                (IArg)method);
     // Other considerations for CURRAIN can be inserted here
     break;
*/
    default:
      Log_error0("Attribute was not found.");
      return ATT_ERR_ATTR_NOT_FOUND;
  }
  // Check whether the length is within bounds.
  if ( offset >= writeLenMax )
  {
    Log_error0("An invalid offset was requested.");
    status = ATT_ERR_INVALID_OFFSET;
  }
  else if ( offset + len > writeLenMax )
  {
    Log_error0("Invalid value length was received.");
    status = ATT_ERR_INVALID_VALUE_SIZE;
  }
  else if ( offset + len < writeLenMin && ( method == ATT_EXECUTE_WRITE_REQ || method == ATT_WRITE_REQ ) )
  {
    // Refuse writes that are lower than minimum.
    // Note: Cannot determine if a Reliable Write (to several chars) is finished, so those will
    //       only be refused if this attribute is the last in the queue (method is execute).
    //       Otherwise, reliable writes are accepted and parsed piecemeal.
    Log_error0("Invalid value length was received.");
    status = ATT_ERR_INVALID_VALUE_SIZE;
  }
  else
  {
    // Copy pValue into the variable we point to from the attribute table.
    memcpy(pAttr->pValue + offset, pValue, len);

    // Only notify application and update length if enough data is written.
    //
    // Note: If reliable writes are used (meaning several attributes are written to using ATT PrepareWrite),
    //       the application will get a callback for every write with an offset + len larger than _LEN_MIN.
    // Note: For Long Writes (ATT Prepare + Execute towards only one attribute) only one callback will be issued,
    //       because the write fragments are concatenated before being sent here.
    if ( offset + len >= writeLenMin )
    {
      changeParamID = paramID;
      *pValueLenVar = offset + len; // Update data length.
    }
  }

  // Let the application know something changed (if it did) by using the
  // callback it registered earlier (if it did).
  if (changeParamID != 0xFF)
    if ( pAppCBs && pAppCBs->pfnChangeCb )
      pAppCBs->pfnChangeCb( connHandle, ENV_SERVICE_SERV_UUID, paramID, pValue, len+offset ); // Call app function from stack task context.

  return status;
}
